===== Acceptor.cpp =====
/**
 * Project 66th
 */

#include "Acceptor.hpp"
#include "Logger.hpp"

/**
 * Acceptor implementation
 */

/**
 * @param ip
 * @param port
 */
Acceptor::Acceptor(const string &ip, unsigned short port)
    : _sock(), _addr(ip, port)
{
}

Acceptor::~Acceptor()
{
}

/**
 * @return void
 */
void Acceptor::ready()
{
    setReuseAddr();
    setReusePort();
    bind();
    listen();
}

/**
 * @return int
 */
int Acceptor::accept()
{
    int connfd = ::accept(_sock.getFd(), nullptr, nullptr);
    if (connfd < 0)
    {
        LOG_ERROR("accept failed");
    }
    else
    {
        LOG_INFO(("new connection fd=" + std::to_string(connfd)).c_str());
    }
    return connfd;
}

/**
 * @return int
 */
int Acceptor::fd()
{
    return _sock.getFd();
}

/**
 * @return void
 */
void Acceptor::setReuseAddr()
{
    int flag = 1;
    setsockopt(_sock.getFd(), SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));
}

/**
 * @return void
 */
void Acceptor::setReusePort()
{
    int flag = 1;
    setsockopt(_sock.getFd(), SOL_SOCKET, SO_REUSEPORT, &flag, sizeof(flag));
}

/**
 * @return void
 */
void Acceptor::bind()
{
    int ret = ::bind(_sock.getFd(), (struct sockaddr *)_addr.getInetAddressPtr(), sizeof(struct sockaddr));
    if (ret < 0)
    {
        LOG_ERROR("bind failed");
        exit(EXIT_FAILURE);
    }
}

/**
 * @return void
 */
void Acceptor::listen()
{
    int ret = ::listen(_sock.getFd(), 4096);
    if (ret < 0)
    {
        LOG_ERROR("listen failed");
        exit(EXIT_FAILURE);
    }
}===== Acceptor.hpp =====
/**
 * Project 66th
 */

#pragma once
#include <string>
#include "Socket.hpp"
#include "InetAddress.hpp"
using std::string;
class Acceptor
{
public:
    /**
     * @param ip
     * @param port
     */
    Acceptor(const string &ip, unsigned short port);

    ~Acceptor();

    void ready();

    int accept();

    int fd();

private:
    Socket _sock;
    InetAddress _addr;

    void setReuseAddr();

    void setReusePort();

    void bind();

    void listen();
};
===== buildCorpus.cpp =====
#include "PageProcessor.hpp"
#include "KeywordProcessor.hpp"
#include "DirectoryScanner.hpp"
#include <iostream>
using namespace std;

int main()
{
    cout << "å¼€å§‹æ„å»ºè¯­æ–™ç´¢å¼•..." << endl;
    PageProcessor pp;
    pp.process("../corpus/webpages"); // è¯­æ–™ç›®å½•

    cout << "å¼€å§‹æ„å»ºè¯å…¸ç´¢å¼•..." << endl;
    KeyWordProcessor kwp;
    kwp.process("../corpus/CN", "../corpus/EN");

    cout << "ç¦»çº¿æ„å»ºå®Œæˆï¼" << endl;
    return 0;
}
===== CacheManage.hpp =====
#pragma once
#include "LRUCache.hpp"
#include "RedisClient.hpp"
#include "KeyRecommander.hpp"
#include "WebPageSearcher.hpp"
#include <string>
#include <memory>
using std::string;

struct MyThread
{
    int id;
    thread th;
    LRUCache cache;
    LRUCache patch;
    MyThread(int tid, size_t cacheCapa, size_t patchCapa)
        : id(tid), cache(cacheCapa), patch(patchCapa) {}
};

// ä¸¤çº§ç¼“å­˜ç®¡ç†å™¨ï¼šä¼˜å…ˆ LRUï¼Œå…¶æ¬¡ Redisï¼Œæœ€åæ–‡ä»¶/è®¡ç®—
class CacheManage
{
public:
    CacheManage(size_t lruCapa, const string &redisUri)
        : _globalCache(lruCapa), _redis(redisUri),
          _recommander("../data/endict.dat", "../data/cndict.dat",
                       "../data/enindex.dat", "../data/cnindex.dat"),
          _searcher("../data/webpages.dat", "../data/weboffset.dat", "../data/invertindex.dat")
    {
    }

    // æŸ¥è¯¢æ¥å£ï¼šå…ˆæŸ¥ LRUï¼Œå†æŸ¥ Redisï¼Œå†æŸ¥åº•å±‚
    string get(MyThread *th, string &key)
    {
        string value;
        // 1. æœ¬åœ°ç¼“å­˜
        if (th->cache.get(key, value))
        {
            return value;
        }

        // 2. Redis
        if (_redis.get(key, value))
        {
            th->cache.put(key, value); // å›å¡« LRU
            return value;
        }
        // 3. çœŸæ­£æŸ¥è¯¢ï¼ˆè½ç›˜è®¡ç®—ï¼‰
        value = queryFromFile(key);
        th->cache.put(key, value);
        th->patch.put(key, value);
        _redis.set(key, value);
        return value;
    }

    // æ·»åŠ çº¿ç¨‹ä¸Šä¸‹æ–‡
    void addThread(std::shared_ptr<MyThread> th)
    {
        _threads.push_back(th);
    }

    // å®šæ—¶åŒæ­¥ï¼šåˆå¹¶patch -> exportAll -> å¹¿æ’­å…¨å±€
    void syncCaches()
    {
        for (auto &th : _threads)
        {
            auto item = th->patch.exportData();
            for (auto &[k, v] : item)
            {
                _globalCache.put(k, v);
            }
            th->patch.clear();
        }

        // å¹¿æ’­å…¨å±€
        auto item = _globalCache.exportData();
        for (auto &th : _threads)
        {
            for (auto &[k, v] : item)
            {
                th->cache.put(k, v);
            }
        }
    }

    // å¯åŠ¨åå°å®šæ—¶åŒæ­¥çº¿ç¨‹
    void startSyncThread(int intervalSec = 10)
    {
        std::thread([this, intervalSec]
                    {
            while (true)
            {
                std::this_thread::sleep_for(std::chrono::seconds(intervalSec));
                syncCaches();
            } })
            .detach();
    }

    ~CacheManage() {}

private:
    // ä»åº•å±‚æŸ¥è¯¢ï¼ˆè°ƒç”¨å…³é”®å­—æ¨è / ç½‘é¡µæœç´¢ï¼‰
    string queryFromFile(const string &key)
    {
        auto pos = key.find(':');
        if (pos == string::npos)
            return "{}";

        int tag = stoi(key.substr(0, pos));
        string query = key.substr(pos + 1);

        if (tag == 1)
        {
            // å…³é”®å­—æ¨è
            bool isChinese = (unsigned char)query[0] & 0x80;
            return isChinese ? _recommander.doQueryCn(query, 5)
                             : _recommander.doQueryEn(query, 5);
        }
        else if (tag == 2)
        {
            // ç½‘é¡µæœç´¢
            return _searcher.doQuery(query);
        }
        return "{}";
    }

private:
    LRUCache _globalCache; // å…¨å±€ä¸»ç¼“å­˜
    RedisClient _redis;    // äºŒçº§ç¼“å­˜
    KeyRecommander _recommander;
    WebPageSearcher _searcher;
    vector<std::shared_ptr<MyThread>> _threads;
};
===== Client.cpp =====
#include <arpa/inet.h>
#include <unistd.h>
#include <cstring>
#include <iostream>
#include "ProtocolParser.hpp"
using namespace std;

int main(int argc, char *argv[])
{
    string ip = "127.0.0.1";
    int port = 8888;

    if (argc == 3)
    {
        ip = argv[1];
        port = atoi(argv[2]);
    }

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        return -1;
    }

    sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    inet_pton(AF_INET, ip.c_str(), &serverAddr.sin_addr);

    if (connect(sockfd, (sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
    {
        perror("connect");
        close(sockfd);
        return -1;
    }

    cout << "Connected to " << ip << ":" << port << endl;

    string line;
    char buf[4096];
    while (true)
    {
        int tag;
        cout << "input tag [1]:å…³é”®è¯æ¨è   [2]:ç½‘é¡µæœç´¢   [å…¶ä»–é€€å‡º]: ";
        cin >> tag;
        if (tag != 1 && tag != 2) // âœ… ä¿®æ­£é€»è¾‘
            break;

        cin.ignore(); // æ¸…æ‰ç¼“å†²åŒºæ¢è¡Œ

        cout << "input query content: ";
        getline(cin, line);
        if (line == "exit") // âœ… æ”¯æŒ exit é€€å‡º
            break;

        Message msg;
        msg.tag = tag;
        msg.length = line.size();
        msg.value = line;

        string packet = ProtocolParser::serialize(msg);
        send(sockfd, packet.c_str(), packet.size(), 0);

        // æ¥æ”¶æ•°æ®
        memset(buf, 0, sizeof(buf));
        int n = recv(sockfd, buf, sizeof(buf) - 1, 0);
        if (n > 0)
        {
            cout << "[Server Reply]: " << endl;
            cout << buf << endl;
        }
        else if (n == 0)
        {
            cout << "Server closed connection." << endl;
            break;
        }
        else
        {
            perror("recv");
            break;
        }
    }

    close(sockfd);
    return 0;
}
===== CMakeLists.txt =====
cmake_minimum_required(VERSION 3.15)

# é¡¹ç›®åç§°
project(SearchEngine)

# æŒ‡å®šC++çš„ç‰ˆæœ¬
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ../)

# ç”Ÿæˆçš„å¯æ‰§è¡Œç¨‹åº
add_executable(SearchEngine
    Acceptor.cpp
    EventLoop.cpp
    InetAddress.cpp
    KeyRecommander.cpp
    WebPageSearcher.cpp
    Logger.cpp
    main.cpp
    ProtocolParser.cpp
    SearchEngineServer.cpp
    Socket.cpp
    SocketIO.cpp
    TaskQueue.cpp
    TcpConnection.cpp
    TcpServer.cpp
    ThreadPool.cpp
    CacheManage.hpp
    LRUCache.hpp
    RedisClient.hpp
)

target_compile_options(SearchEngine PRIVATE
    -g
)

target_link_libraries(SearchEngine PRIVATE
    pthread
    log4cpp
    tinyxml2
    redis++
)

add_executable(Client
    Client.cpp
    ProtocolParser.cpp
)

target_compile_options(Client PRIVATE
    -g
)

target_link_libraries(Client PRIVATE
    pthread
    log4cpp
    tinyxml2
)

add_executable(Corpus
    buildCorpus.cpp
    KeywordProcessor.cpp
    PageProcessor.cpp
    DirectoryScanner.cpp
)

target_compile_options(Corpus PRIVATE
    -g
)

target_link_libraries(Corpus PRIVATE
    log4cpp
    tinyxml2
)===== DirectoryScanner.cpp =====
#include "DirectoryScanner.hpp"
#include <dirent.h>
#include <sys/types.h>
#include <iostream>
using namespace std;

// éå†ç›®å½•
vector<string> DirectoryScanner::scan(const string& dir){
    vector<string> files;
    DIR *dp = opendir(dir.c_str());
    // åˆ¤æ–­ç›®å½•æ˜¯å¦åœ¨å­˜åœ¨
    if(!dp){
        perror("fail open");
        return files;
    }

    struct dirent* entry;
    while((entry = readdir(dp)) != nullptr){
        string name(entry->d_name);
        if(name == "." || name == "..")
            continue;
        files.emplace_back(dir + "/" +name);
    }
    closedir(dp);
    return files;
}
===== DirectoryScanner.hpp =====
#pragma once
#include <vector>
#include <string>
using std::vector;
using std::string;

class DirectoryScanner
{
public:
    /**
     * éå†ç›®å½• dir, è·å–ç›®å½•é‡Œé¢çš„æ‰€æœ‰æ–‡ä»¶å
     */ 
    static vector<string> scan(const string& dir);

private:
    DirectoryScanner() = delete;
};
===== EventLoop.cpp =====
/**
 * Project 66th
 */

#include "EventLoop.hpp"
#include "Logger.hpp"

/**
 * EventLoop implementation
 */

/**
 * @param acc
 */
EventLoop::EventLoop(Acceptor &acc) : _epfd(createEpollFd()), _evtfd(createEventFd()), _isLooping(false), _acceptor(acc), _evlist(OPEN_MAX)
{
    addEpollReadFd(_acceptor.fd());
    addEpollReadFd(_evtfd);
}

EventLoop::~EventLoop()
{
}

/**
 * @return void
 */
void EventLoop::loop()
{
    _isLooping = true;
    while (_isLooping)
    {
        waitEpollFd();
    }
}

/**
 * @return void
 */
void EventLoop::unloop()
{
    _isLooping = false;
}

/**
 * @param cb
 */
void EventLoop::setNewConnectionCallBack(TcpConnectionCallBack &&cb)
{
    _onNewConnection = std::move(cb);
}

/**
 * @param cb
 */
void EventLoop::setMessageCallBack(TcpConnectionCallBack &&cb)
{
    _onMessage = std::move(cb);
}

/**
 * @param cb
 */
void EventLoop::setCloseCallBack(TcpConnectionCallBack &&cb)
{
    _onClose = std::move(cb);
}

/**
 * @return int
 */

/**
 * @return void
 */
void EventLoop::handleRead()
{
    uint64_t flag = 1;
    read(_evtfd, &flag, sizeof(flag));
    doPendingFunctors();
}

/**
 * @return void
 */
void EventLoop::wakeup()
{
    uint64_t flag = 1;
    write(_evtfd, &flag, sizeof(flag)); // å”¤é†’epoll_wait
}

/**
 * @param cb
 * @return void
 */
void EventLoop::runInLoop(function<void()> cb)
{
    {
        lock_guard<mutex> lg(_mutex);
        _pendingFunctors.push_back(std::move(cb));
    }
    wakeup();
}

/**
 * @return void
 */
void EventLoop::doPendingFunctors()
{
    vector<function<void()>> functors;
    {
        lock_guard<mutex> lg(_mutex);
        functors.swap(_pendingFunctors);
    }
    for (auto &f : functors)
        f();
}

int EventLoop::createEventFd()
{
    int evtfd = eventfd(0, EFD_NONBLOCK);
    if (evtfd < 0)
    {
        LOG_ERROR("eventfd create failed");
        exit(EXIT_FAILURE);
    }
    return evtfd;
}
/**
 * @return int
 */
int EventLoop::createEpollFd()
{
    _epfd = epoll_create(OPEN_MAX);
    if (_epfd < 0)
    {
        LOG_ERROR("epoll create failed");
        exit(EXIT_FAILURE);
    }
    return _epfd;
}

/**
 * @param fd
 * @return void
 */
void EventLoop::addEpollReadFd(int fd)
{
    struct epoll_event event;
    event.data.fd = fd;
    event.events = EPOLLIN;
    int ret = epoll_ctl(_epfd, EPOLL_CTL_ADD, fd, &event);
    if (ret < 0)
    {
        LOG_ERROR("epoll add failed");
        exit(EXIT_FAILURE);
    }
}

/**
 * @param fd
 * @return void
 */
void EventLoop::delEpollReadFd(int fd)
{
    int ret = epoll_ctl(_epfd, EPOLL_CTL_DEL, fd, nullptr);
    if (ret < 0)
    {
        LOG_ERROR("epoll del failed");
        exit(EXIT_FAILURE);
    }
}

/**
 * @return void
 */
void EventLoop::waitEpollFd()
{
    struct epoll_event ep[OPEN_MAX];
    int nready = epoll_wait(_epfd, ep, OPEN_MAX, -1);
    if (nready < 0)
    {
        LOG_ERROR("epoll wait failed");
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i < nready; ++i)
    {
        if (ep[i].data.fd == _acceptor.fd())
        {
            handleNewConnection();
        }
        else if (ep[i].data.fd == _evtfd)
        {
            handleRead();
        }
        else
        {
            handleMessage(ep[i].data.fd);
        }
    }
}
/**
 * @return void
 */
void EventLoop::handleNewConnection()
{
    int connfd = _acceptor.accept();
    if (connfd < 0)
    {
        LOG_ERROR("handleNewConnection failed");
        exit(EXIT_FAILURE);
    }
    LOG_INFO(("Accepted new connection fd=" + std::to_string(connfd)).c_str());

    auto conn = make_shared<TcpConnection>(connfd, this);
    // æ³¨å†Œå›è°ƒ
    conn->setNewConnectionCallback(_onNewConnection);
    conn->setMessageCallback(_onMessage);
    conn->setCloseCallback(_onClose);

    _conns[connfd] = conn;
    addEpollReadFd(connfd);

    conn->handleNewConnectionCallback();
}

/**
 * @param fd
 * @return void
 */
void EventLoop::handleMessage(int fd)
{
    auto it = _conns.find(fd);
    if (it != _conns.end())
    {
        auto conn = it->second;
        bool flag = conn->isClosed();
        if (flag)
        {
            if (_onClose)
            {
                delEpollReadFd(fd);
                _conns.erase(it);
                close(fd);
                conn->handleCloseCallback();
            }
            LOG_INFO(("connection closed fd=" + std::to_string(fd)).c_str());
        }
        else
        {
            conn->handleMessageCallback();
            LOG_DEBUG(("message from fd=" + std::to_string(fd)).c_str());
        }
    }
}===== EventLoop.hpp =====
/**
 * Project 66th
 */

#pragma once
#include "Acceptor.hpp"
#include "TcpConnection.hpp"
#include <vector>
#include <memory>
#include <map>
#include <mutex>
#include <sys/eventfd.h>
#include <functional>
using std::function;
using std::lock_guard;
using std::make_shared;
using std::map;
using std::mutex;
using std::shared_ptr;
using std::vector;
class TcpConnection;
#define OPEN_MAX 1024
class EventLoop
{
public:
    /**
     * @param acc
     */

    using TcpConnectionPtr = shared_ptr<TcpConnection>;
    using TcpConnectionCallBack = function<void(const TcpConnectionPtr &)>;
    EventLoop(Acceptor &acc);

    ~EventLoop();

    void loop();

    void unloop();

    /**
     * @param cb
     */
    void setNewConnectionCallBack(TcpConnectionCallBack &&cb);

    /**
     * @param cb
     */
    void setMessageCallBack(TcpConnectionCallBack &&cb);

    /**
     * @param cb
     */
    void setCloseCallBack(TcpConnectionCallBack &&cb);

    int createEventFd();

    void handleRead();

    void wakeup();

    /**
     * @param cb
     */
    void runInLoop(function<void()> cb);

    void doPendingFunctors();

private:
    int _epfd;
    vector<struct epoll_event> _evlist;
    bool _isLooping;
    Acceptor &_acceptor;
    map<int, shared_ptr<TcpConnection>> _conns;
    TcpConnectionCallBack _onNewConnection;
    TcpConnectionCallBack _onMessage;
    TcpConnectionCallBack _onClose;
    int _evtfd;
    std::vector<function<void()>> _pendingFunctors;
    mutex _mutex;

    int createEpollFd();

    /**
     * @param fd
     */
    void addEpollReadFd(int fd);

    /**
     * @param fd
     */
    void delEpollReadFd(int fd);

    void waitEpollFd();

    void handleNewConnection();

    /**
     * @param fd
     */
    void handleMessage(int fd);
};
===== InetAddress.cpp =====
/**
 * Project 66th
 */


#include "InetAddress.hpp"

/**
 * InetAddress implementation
 */


/**
 * @param ip
 * @param port
 */
InetAddress::InetAddress(const string & ip, unsigned short port) {
    _addr.sin_family = AF_INET;
    _addr.sin_addr.s_addr = inet_addr(ip.c_str());
    _addr.sin_port = htons(port);
}

/**
 * @param addr
 */
InetAddress::InetAddress(const struct sockaddr_in & addr) {
    _addr = addr;
}

InetAddress::~InetAddress() {

}

/**
 * @return string
 */
string InetAddress::getIp() {
    return string(inet_ntoa(_addr.sin_addr));
}

/**
 * @return unsigned short
 */
unsigned short InetAddress::getPort() {
    return ntohs(_addr.sin_port);
}

/**
 * @return const struct sockaddr_in *
 */
const struct sockaddr_in * InetAddress::getInetAddressPtr() {
    return &_addr;
}===== InetAddress.hpp =====
/**
 * Project 66th
 */


#pragma once
#include <iostream>
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/epoll.h>
using std::cout;
using std::endl;
using std::string;
class InetAddress {
public: 
    
/**
 * @param ip
 * @param port
 */
InetAddress(const string & ip, unsigned short port);
    
/**
 * @param addr
 */
InetAddress(const struct sockaddr_in & addr);
    
~InetAddress();
    
string getIp();
    
unsigned short getPort();
    
const struct sockaddr_in * getInetAddressPtr();
private: 
    struct sockaddr_in _addr;
};
===== KeyRecommander.cpp =====
#include "KeyRecommander.hpp"
#include <fstream>
#include <algorithm>
#include <sstream>
#include <set>
#include <queue>
#include <string>
#include <nlohmann/json.hpp>
#include <iconv.h>

using std::string;
using json = nlohmann::json;
// å€™é€‰è¯
struct CandidateWords
{
    string word;
    int editDist;
    int freq;
    bool operator<(const CandidateWords &rhs) const
    {
        if (editDist != rhs.editDist)
            return editDist > rhs.editDist; // ç¼–è¾‘è·ç¦»å°ä¼˜å…ˆ
        if (freq != rhs.freq)
            return freq < rhs.freq; // è¯é¢‘å¤§ä¼˜å…ˆ
        return word > rhs.word;     // å­—å…¸åºå°ä¼˜å…ˆ
    }
};

KeyRecommander::KeyRecommander(const string &enDictFile, const string &cnDictFile, const string &enIndexFile, const string &cnIndexDictFile)
{
    loadDictFile(enDictFile, cnDictFile);
    loadIndexFile(enIndexFile, cnIndexDictFile);
}

// è‹±æ–‡æŸ¥è¯¢
string KeyRecommander::doQueryEn(const string &word, int k)
{
    std::set<int> candidateIds; // è®¡ç®—è¯æ±‡æ‰€å«å­—ç¬¦å‡ºç°çš„ä½ç½®(dictè¡Œå·)
    for (char ch : word)
    {
        string key(1, ch); // æ„é€ ä¸ºstring -> unordered_map.first
        if (en_index.count(key))
        {                                                                    // è‹¥ç´¢å¼•åº“ä¸­å­˜åœ¨è¯¥å­—ç¬¦
            candidateIds.insert(en_index[key].begin(), en_index[key].end()); // è®°å½•è¯¥å­—ç¬¦å‡ºç°çš„è®°å½•(å­—å…¸è¡Œå·)
        }
    }

    std::priority_queue<CandidateWords> pq; // ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæ ¹æ®ä¼˜å…ˆçº§å¤§å°æ’åº
    for (int id : candidateIds)
    {
        const auto &candidate = en_dict[id].first;
        int dist = editDistance(word, candidate);
        int freq = en_dict[id].second;
        pq.push({candidate, dist, freq});
    }

    json result;
    result["candidates"] = json::array();
    for (int i = 0; i < k && !pq.empty(); ++i)
    {
        auto top = pq.top();
        pq.pop();
        result["candidates"].push_back({{"word", top.word}, {"freq", top.freq}, {"dist", top.editDist}});
    }

    return result.dump(4);
}

// ğŸ”¹ UTF-8 åˆ†å‰²ï¼ˆä¸­æ–‡ç”¨ï¼‰
static std::vector<string> splitUtf8(const string &s)
{
    std::vector<string> res;
    for (size_t i = 0; i < s.size();)
    {
        unsigned char c = s[i];
        int len = 1;
        if ((c & 0x80) == 0)
            len = 1;
        else if ((c & 0xE0) == 0xC0)
            len = 2;
        else if ((c & 0xF0) == 0xE0)
            len = 3; // ä¸­æ–‡å¸¸ç”¨
        else if ((c & 0xF8) == 0xF0)
            len = 4;
        res.push_back(s.substr(i, len));
        i += len;
    }
    return res;
}

// ä¸­æ–‡æŸ¥è¯¢
string KeyRecommander::doQueryCn(const string &word, int k)
{
    auto chars = splitUtf8(word);

    std::set<int> candidateIds;
    for (auto &ch : chars)
    {
        if (cn_index.count(ch))
        {
            candidateIds.insert(cn_index[ch].begin(), cn_index[ch].end());
        }
    }

    std::priority_queue<CandidateWords> pq;
    for (int id : candidateIds)
    {
        const auto &cand = cn_dict[id].first;
        int dist = editDistance(word, cand);
        int freq = cn_dict[id].second;
        pq.push({cand, dist, freq});
    }

    json result;
    result["candidates"] = json::array();
    for (int i = 0; i < k && !pq.empty(); ++i)
    {
        auto top = pq.top();
        pq.pop();
        result["candidates"].push_back({{"word", top.word},
                                        {"freq", top.freq}});
    }
    return result.dump(4);
}

// è®¡ç®—ç¼–è¾‘è·ç¦»
int KeyRecommander::editDistance(const std::string &lhs, const std::string &rhs)
{
    size_t m = lhs.size(), n = rhs.size();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));
    for (size_t i = 0; i <= m; ++i)
        dp[i][0] = i;
    for (size_t j = 0; j <= n; ++j)
        dp[0][j] = j;

    for (size_t i = 1; i <= m; ++i)
    {
        for (size_t j = 1; j <= n; ++j)
        {
            if (lhs[i - 1] == rhs[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = std::min({dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1});
        }
    }
    return dp[m][n];
}

// åŠ è½½å­—å…¸
void KeyRecommander::loadDictFile(const string &enDictFile, const string &cnDictFile)
{
    std::ifstream ifs_en(enDictFile);
    if (!ifs_en.is_open())
    {
        std::cerr << "Failed to open English dict file: " << enDictFile << std::endl;
        return;
    }
    string word;
    int freq;
    while (ifs_en >> word >> freq)
    {
        en_dict.emplace_back(word, freq);
    }

    std::ifstream ifs_ch(cnDictFile);
    if (!ifs_ch.is_open())
    {
        std::cerr << "Failed to open Chinese dict file: " << cnDictFile << std::endl;
        return;
    }
    while (ifs_ch >> word >> freq)
    {
        cn_dict.emplace_back(word, freq);
    }
}

// åŠ è½½ç´¢å¼•åº“
void KeyRecommander::loadIndexFile(const string &enIndexFile, const string &cnIndexDictFile)
{
    std::ifstream ifs_en(enIndexFile);
    if (!ifs_en.is_open())
    {
        std::cerr << "Failed to open English index file: " << enIndexFile << std::endl;
        return;
    }

    string key;
    int idx;
    string line;
    while (std::getline(ifs_en, line))
    {
        std::istringstream iss(line);
        if (!(iss >> key))
            continue;
        while (iss >> idx)
        {
            en_index[key].push_back(idx);
        }
    }

    std::ifstream ifs_ch(cnIndexDictFile);
    if (!ifs_ch.is_open())
    {
        std::cerr << "Failed to open Chinese index file: " << cnIndexDictFile << std::endl;
        return;
    }
    while (std::getline(ifs_ch, line))
    {
        std::istringstream iss(line);
        if (!(iss >> key))
            continue;
        while (iss >> idx)
        {
            cn_index[key].push_back(idx);
        }
    }
}
===== KeyRecommander.hpp =====
#pragma once
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
using std::string;
using std::unordered_map;
using std::vector;
class KeyRecommander
{
public:
    KeyRecommander(const string &enDictFile, const string &cnDictFile, const string &enIndexFile, const string &cnIndexDictFile);
    ~KeyRecommander() {}
    string doQueryCn(const string &word,int k = 3);
    string doQueryEn(const string &word,int k = 3);

private:
    int editDistance(const string &lhs, const string &rhs);
    void loadDictFile(const string &enDictFile, const string &cnDictFile);
    void loadIndexFile(const string &enIndexFile, const string &cnIndexDictFile);

    // dict: ä¸‹æ ‡ -> (å•è¯, è¯é¢‘)
    vector<std::pair<string, int>> cn_dict; // _indexä¸­çš„vectorå…ƒç´ èƒ½å¤Ÿç›´æ¥å¯¹åº” _dictä¸­vectorçš„ä¸‹è¡¨ï¼Œä¸ç”¨é¢å¤–å»ºç«‹æ˜ å°„å…³ç³»ï¼Œæ‰€ä»¥ä¸é‡‡ç”¨map
    vector<std::pair<string, int>> en_dict;
    unordered_map<string, vector<int>> cn_index;
    unordered_map<string, vector<int>> en_index;
};
===== KeywordProcessor.cpp =====
#include "KeywordProcessor.hpp"
#include "DirectoryScanner.hpp"
#include <fstream>
#include <sstream>
#include <iostream>
#include <map>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <cctype>
#include "utf8cpp/utf8.h"
using std::map;
using std::vector;

// è¾…åŠ©å‡½æ•°(å­—ç¬¦åˆ¤æ–­)
static bool isAlpha(char c)
{
    return std::isalpha(static_cast<unsigned char>(c));
}

// åˆå§‹åŒ–jieba
KeyWordProcessor::KeyWordProcessor()
    : m_tokenizer(
          "/usr/local/dict/jieba.dict.utf8", // è¯å…¸
          "/usr/local/dict/hmm_model.utf8",  // HMM
          "/usr/local/dict/user.dict.utf8",  // ç”¨æˆ·è¯å…¸
          "/usr/local/dict/idf.utf8",        // idf
          "/usr/local/dict/stop_words.utf8"  // åœç”¨è¯
      )
{
    std::ifstream ifs_en("/home/zhang/SearchEngine/corpus/stopwords/en_stopwords.txt");
    string word;
    while (ifs_en >> word)
    {   
        m_enStopWords.insert(word);
    }

    std::ifstream ifs_ch("/home/zhang/SearchEngine/corpus/stopwords/cn_stopwords.txt");
    while (ifs_ch >> word)
    {
        m_chStopWords.insert(word);
    }
}

void KeyWordProcessor::process(const string &chDir, const string &enDir)
{
    create_en_dict(enDir, "../data/endict.dat");
    build_en_index("../data/endict.dat", "../data/enindex.dat");

    create_cn_dict(chDir, "../data/cndict.dat");
    build_cn_index("../data/cndict.dat", "../data/cnindex.dat");
}

// è‹±æ–‡éƒ¨åˆ†
// ç”Ÿæˆè¯å…¸åº“(å•è¯ + é¢‘ç‡)
void KeyWordProcessor::create_en_dict(const string &dir, const string &outfile)
{
    map<string, int> dict;
    auto files = DirectoryScanner::scan(dir);

    for (auto &file : files)
    {
        std::ifstream ifs(file);
        if (!ifs.is_open())
        {
            continue;
        }

        // å»æ‰æ•°å­—å’Œæ ‡ç‚¹ç¬¦å· + è½¬å°å†™
        string line;
        while (std::getline(ifs, line))
        {

            for (auto &ch : line)
            {
                if (!isAlpha(ch))
                {
                    ch = ' ';
                }
                ch = std::tolower(ch);
            }

            // ç»Ÿè®¡æ¯ä¸ªå•è¯(Token)çš„å‡ºç°é¢‘ç‡
            std::istringstream iss(line);
            string token;
            while (iss >> token)// ç©ºç™½å­—ç¬¦è¿›è¡Œåˆ‡åˆ†
            {
                if (m_enStopWords.count(token))
                {
                    continue;
                }
                dict[token]++;// string â€”> frequency
            }
        }
    }

    // è¾“å‡ºè¯å…¸åº“
    std::ofstream ofs(outfile);
    if (!ofs.is_open())
    {
        std::cerr << "Error open file" << std::endl;
        return;
    }
    for (auto &[w, f] : dict)
    {
        ofs << w << " " << f << "\n";
    }
}

// ç”Ÿæˆè‹±æ–‡ç´¢å¼•åº“
void KeyWordProcessor::build_en_index(const string &dict, const string &index)
{

    std::ifstream ifs(dict);
    if (!ifs.is_open())
    {
        std::cerr << "Error: cannot open dict file " << dict << std::endl;
        return;
    }

    std::map<char, std::vector<int>> charIndex; // å­—æ¯ -> è¡Œå·é›†åˆ
    std::vector<std::string> words;             // ä¿å­˜è¯å…¸é‡Œçš„å•è¯,é€šè¿‡è¡Œå·åæŸ¥å•è¯

    std::string word;
    int freq;
    int lineId = 0;
    while (ifs >> word >> freq)
    {
        words.push_back(word);

        // éå†å•è¯ä¸­çš„æ¯ä¸ªå­—æ¯
        for (char c : word)
        {
            auto &vec = charIndex[c];
            // é¿å…é‡å¤æ’å…¥
            if (vec.empty() || vec.back() != lineId)
            {
                vec.push_back(lineId);
            }
        }
        lineId++;
    }

    // å†™ç´¢å¼•æ–‡ä»¶
    std::ofstream ofs(index);
    if (!ofs.is_open())
    {
        std::cerr << "Error: cannot open index file " << index << std::endl;
        return;
    }

    for (auto &[ch, vec] : charIndex)
    {
        ofs << ch << " ";
        for (int id : vec)
        {
            ofs << id << " ";
        }
        ofs << "\n";
    }
}

// åˆ¤æ–­æ±‰å­—
static bool isChinese(const std::string &s)
{
    auto it = s.begin();
    while (it != s.end())
    {
        char32_t cp = utf8::next(it, s.end());
        if (!((cp >= 0x4E00 && cp <= 0x9FFF) ||   // åŸºæœ¬æ±‰å­—
              (cp >= 0x3400 && cp <= 0x4DBF) ||   // æ‰©å±•A
              (cp >= 0x20000 && cp <= 0x2A6DF) || // æ‰©å±•B
              (cp >= 0x2A700 && cp <= 0x2B73F) || // æ‰©å±•C
              (cp >= 0x2B740 && cp <= 0x2B81F) || // æ‰©å±•D
              (cp >= 0x2B820 && cp <= 0x2CEAF) || // æ‰©å±•E
              (cp >= 0x2CEB0 && cp <= 0x2EBEF)    // æ‰©å±•F
              ))
        {
            return false; // åªè¦æœ‰ä¸€ä¸ªä¸æ˜¯æ±‰å­—ï¼Œå°±åˆ¤å®šä¸º false
        }
    }
    return true;
}

// ä¸­æ–‡éƒ¨åˆ†
void KeyWordProcessor::create_cn_dict(const string &dir, const string &outfile)
{
    map<string, int> dict;
    auto files = DirectoryScanner::scan(dir);

    for (auto &file : files)
    {
        std::ifstream ifs(file);
        if (!ifs.is_open())
        {
            continue;
        }

        // è¯»å–æ•´ä¸ªæ–‡ä»¶å†…å®¹
        string content((std::istreambuf_iterator<char>(ifs)),
                       std::istreambuf_iterator<char>());
        // jiebaåˆ†è¯
        vector<string> words;
        m_tokenizer.Cut(content, words, true); // true = HMM = æ··åˆæ¨¡å¼

        for (auto &w : words)
        {
            if (m_chStopWords.count(w) || !isChinese(w))
                continue; // è¿‡æ»¤åœç”¨è¯æˆ–éæ±‰å­—
            dict[w]++;
        }
    }

    // è¾“å‡ºè¯å…¸åº“
    std::ofstream ofs(outfile);
    if (!ofs.is_open())
    {
        std::cerr << "Error open file" << std::endl;
        return;
    }
    for (auto &[w, f] : dict)
    {
        ofs << w << " " << f << "\n";
    }
}

// ç”Ÿæˆä¸­æ–‡ç´¢å¼•åº“
void KeyWordProcessor::build_cn_index(const string &dict, const string &index)
{
    std::ifstream ifs(dict);
    if (!ifs.is_open())
    {
        std::cerr << "Error: cannot open dict file " << dict << std::endl;
        return;
    }

    map<string, set<int>> cnindex; // ä¸­æ–‡æ±‰å­— -> è¡Œå·é›†åˆ
    vector<string> words;             // ä¿å­˜è¯å…¸é‡Œçš„å•è¯, é€šè¿‡è¡Œå·åæŸ¥å•è¯

    string word;
    int freq;
    int lineId = 0;

    while (ifs >> word >> freq)
    {
        words.push_back(word);

        // ç”¨ utfcpp éå†ä¸€ä¸ªä¸ªæ±‰å­—
        for (auto it = word.begin(); it != word.end();)
        {
            char32_t cp = utf8::next(it, word.end()); // å–ä¸€ä¸ª codepoint å¹¶å‰è¿›è¿­ä»£å™¨
            std::string ch;
            utf8::append(cp, std::back_inserter(ch)); // è½¬å› UTF-8

            cnindex[ch].insert(lineId); // å»ºç«‹ç´¢å¼•ï¼šæ±‰å­— -> è¡Œå·
        }

        lineId++;
    }

    // å†™ç´¢å¼•æ–‡ä»¶
    std::ofstream ofs(index);
    if (!ofs.is_open())
    {
        std::cerr << "Error: cannot open index file " << index << std::endl;
        return;
    }

    for (auto &[ch, vec] : cnindex)
    {
        ofs << ch << " ";
        for (int id : vec)
        {
            ofs << id << " ";
        }
        ofs << "\n";
    }
}
===== KeywordProcessor.hpp =====
// KeywordProcessor.h
#pragma once
#include <cppjieba/Jieba.hpp>
#include <string>
#include <set>
using std::string;
using std::set;

class KeyWordProcessor {
public:
    KeyWordProcessor();
	
    // chDir: ä¸­æ–‡è¯­æ–™åº“
    // enDir: è‹±æ–‡è¯­æ–™åº“
    void process(const string& chDir, const string& enDir);

private:
    void create_cn_dict(const string& dir, const string& outfile);
    void build_cn_index(const string& dict, const string& index);

    void create_en_dict(const string& dir, const string& outfile);
    void build_en_index(const string& dict, const string& index);
private:
    cppjieba::Jieba m_tokenizer;
    set<string> m_enStopWords;
    set<string> m_chStopWords;
};===== Logger.cpp =====
#include "Logger.hpp"
#include <log4cpp/Category.hh>
#include <log4cpp/OstreamAppender.hh>
#include <log4cpp/FileAppender.hh>
#include <log4cpp/RollingFileAppender.hh>
#include <log4cpp/PatternLayout.hh>

// åˆå§‹åŒ–é™æ€æˆå‘˜å˜é‡
// åˆå§‹åŒ–é™æ€æˆå‘˜å˜é‡
Logger *Logger::_pInstance = nullptr;
Category *Logger::_root = nullptr;

// æ„é€ å‡½æ•°
Logger::Logger()
{
    log4cpp::PatternLayout *layout1 = new log4cpp::PatternLayout();
    layout1->setConversionPattern("[%d] [%p] %c: %m%n");

    log4cpp::PatternLayout *layout2 = new log4cpp::PatternLayout();
    layout2->setConversionPattern("[%d] [%p] %c: %m%n");

    log4cpp::PatternLayout *layout3 = new log4cpp::PatternLayout();
    layout3->setConversionPattern("[%d] [%p] %c: %m%n");

    // ç»ˆç«¯è¾“å‡º
    OstreamAppender *consoleAppender = new OstreamAppender("console", &std::cout);
    consoleAppender->setLayout(layout1);
    // æ–‡ä»¶è¾“å‡º
    FileAppender *fileAppender = new FileAppender("file", "../log/log.txt");
    fileAppender->setLayout(layout2);

    // å›å·æ–‡ä»¶è¾“å‡ºï¼ˆè‡ªåŠ¨æ»šåŠ¨ï¼‰
    log4cpp::RollingFileAppender *rollingAppender = new log4cpp::RollingFileAppender(
        "rolling",         // åç§°
        "../log/rolling_log.txt", // æ–‡ä»¶å
        5 * 1024 * 1024,   // æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆ5MBï¼‰
        3                  // æœ€å¤§å¤‡ä»½æ•°é‡
    );
    rollingAppender->setLayout(layout3);

    // è®¾ç½®è¾“å‡ºä¿¡æ¯
    _root = &Category::getRoot();
    _root->addAppender(consoleAppender);
    _root->addAppender(fileAppender);
    _root->addAppender(rollingAppender);
    _root->setPriority(Priority::DEBUG);
}

// ææ„å‡½æ•°
Logger::~Logger()
{
    if (_root)
    {
        _root->removeAllAppenders();
    }
    Category::shutdown(); // æ¸…ç†èµ„æº
}

// å•ä¾‹æ–¹æ³•
Logger *Logger::getInstance()
{
    if (!_pInstance)
    {
        _pInstance = new Logger();
    }
    return _pInstance;
}

// å•ä¾‹é”€æ¯æ–¹æ³•
void Logger::destroy()
{
    if (_pInstance)
    {
        delete _pInstance;
        _pInstance = nullptr;
    }
}

// æ—¥å¿—è¾“å‡ºæ–¹æ³•
void Logger::warn(const char *file, int line, const char *func, const char *msg)
{
    _root->warn("[%s:%d:%s] %s", file, line, func, msg);
}

void Logger::error(const char *file, int line, const char *func, const char *msg)
{
    _root->error("[%s:%d:%s] %s", file, line, func, msg);
}

void Logger::debug(const char *file, int line, const char *func, const char *msg)
{
    _root->debug("[%s:%d:%s] %s", file, line, func, msg);
}

void Logger::info(const char *file, int line, const char *func, const char *msg)
{
    _root->info("[%s:%d:%s] %s", file, line, func, msg);
}
===== Logger.hpp =====
#ifndef LOGGER_H
#define LOGGER_H
#include <iostream>
#include <log4cpp/OstreamAppender.hh>
#include <log4cpp/PatternLayout.hh>
#include <log4cpp/Category.hh>
using namespace std;
using namespace log4cpp;

#define LOG_WARN(msg) Logger::getInstance()->warn(__FILE__,__LINE__,__FUNCTION__,msg)
#define LOG_ERROR(msg) Logger::getInstance()->error(__FILE__,__LINE__,__FUNCTION__,msg)
#define LOG_DEBUG(msg) Logger::getInstance()->debug(__FILE__,__LINE__,__FUNCTION__,msg)
#define LOG_INFO(msg) Logger::getInstance()->info(__FILE__,__LINE__,__FUNCTION__,msg)




class Logger{
public:
    void warn(const char * file, int line, const char * func, const char * msg);
    void error(const char * file, int line, const char * func, const char * msg);
    void debug(const char * file, int line, const char * func, const char * msg);
    void info(const char * file, int line, const char * func, const char * msg);

    static Logger * getInstance();

    static void destroy();


private:
    Logger();
    ~Logger();
    Logger(const Logger &) = delete;
    Logger & operator=(const Logger &) = delete;
    static Logger * _pInstance;
    static Category * _root;
};


#endif===== LRUCache.hpp =====
#pragma once
#include <mutex>
#include <string>
#include <unordered_map>
#include <list>
using std::list;
using std::lock_guard;
using std::mutex;
using std::pair;
using std::string;
using std::unordered_map;
// LRUCache: æœ€è¿‘æœ€å°‘ä½¿ç”¨ç¼“å­˜
// ä½¿ç”¨ åŒå‘é“¾è¡¨ + å“ˆå¸Œè¡¨ å®ç° O(1) æŸ¥æ‰¾å’Œæ›´æ–°
class LRUCache
{
public:
    explicit LRUCache(size_t capacity) : _capacity(capacity) {}

    // ä»ç¼“å­˜è·å–key -> value
    bool get(const string &key, string &value)
    {
        lock_guard<mutex> lg(_mutex);
        auto it = _map.find(key);
        if (it == _map.end())
            return false;

        // å°†è¯¥èŠ‚ç‚¹ç§»åŠ¨åˆ°é“¾è¡¨å¤´éƒ¨(æœ€è¿‘ä½¿ç”¨)
        _list.splice(_list.begin(), _list, it->second);
        value = it->second->second;
        return true;
    }

    void put(const string &key, const string &value)
    {
        lock_guard<mutex> lg(_mutex);
        auto it = _map.find(key);
        if (it != _map.end())
        {
            // keyå­˜åœ¨ï¼Œæ›´æ–°å€¼å¹¶ä¸”ç§»åŠ¨åˆ°é“¾è¡¨å¤´éƒ¨
            it->second->second = value;
            _list.splice(_list.begin(), _list, it->second);
            return;
        }
        // è¶…å‡ºå®¹é‡,æ·˜æ±°å°¾éƒ¨èŠ‚ç‚¹
        if (_list.size() >= _capacity)
        {
            auto last = _list.back();
            _map.erase(last.first);
            _list.pop_back();
        }
        _list.emplace_front(key, value);
        _map[key] = _list.begin();
    }

    // å¯¼å‡ºæ‰€æœ‰çš„key-value,åŒæ­¥å…±äº«ç¼“å­˜
    vector<pair<string,string>> exportData(){
        lock_guard<mutex> lg(_mutex);
        vector<pair<string,string>> res;
        for(auto &kv : _list){
            res.push_back(kv);
        }
        return res;
    }

    void clear(){
        lock_guard<mutex> lg(_mutex);
        _list.clear();
        _map.clear();
    }

    ~LRUCache() {}

private:
    size_t _capacity;                                    // ç¼“å­˜å®¹é‡
    list<pair<string, string>> _list;                    // (key,value) é“¾è¡¨
    unordered_map<string, decltype(_list.begin())> _map; // å“ˆå¸Œç´¢å¼•
    mutex _mutex;                                        // çº¿ç¨‹å®‰å…¨
};
===== main.cpp =====
#include "SearchEngineServer.hpp"
#include "Logger.hpp"
#include <iostream>
#include <csignal>

using namespace std;

// å…¨å±€ server æŒ‡é’ˆï¼Œç”¨äºä¿¡å·å¤„ç†
SearchEngineServer *g_server = nullptr;

void signalHandler(int sig) {
    if (sig == SIGINT || sig == SIGTERM) {
        LOG_WARN(("Caught signal " + std::to_string(sig) + ", stopping server...").c_str());
        if (g_server) {
            g_server->stop();
        }
        exit(0);
    }
}

int main(int argc, char **argv)
{
    string ip = "127.0.0.1";
    int port = 8888;

    if (argc == 3) {
        ip = argv[1];
        port = atoi(argv[2]);
    }

    LOG_INFO(("Starting SearchEngineServer on " + ip + ":" + std::to_string(port)).c_str());

    SearchEngineServer server(ip, port);
    g_server = &server;

    // æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°ï¼Œæ–¹ä¾¿ Ctrl+C åœæ­¢æœåŠ¡
    signal(SIGINT, signalHandler);
    signal(SIGTERM, signalHandler);

    server.start();

    return 0;
}
===== PageProcessor.cpp =====
#include "PageProcessor.hpp"
#include "simhash/Simhasher.hpp"
#include "DirectoryScanner.hpp"
#include <tinyxml2.h>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
#include <set>
#include <sstream>
#include <fstream>
#include <cmath>
#include <codecvt>
#include <locale>

using namespace tinyxml2;
using std::ofstream;
using std::ostringstream;
using std::set;
using std::string;
using std::unordered_map;
using std::vector;

// åˆå§‹åŒ–æ„é€ å‡½æ•°
PageProcessor::PageProcessor()
    : m_tokenizer("/usr/local/dict/jieba.dict.utf8",
                  "/usr/local/dict/hmm_model.utf8",
                  "/usr/local/dict/user.dict.utf8",
                  "/usr/local/dict/idf.utf8",
                  "/usr/local/dict/stop_words.utf8"),
      m_hasher("/usr/local/dict/jieba.dict.utf8",
               "/usr/local/dict/hmm_model.utf8",
               "/usr/local/dict/idf.utf8",
               "/usr/local/dict/stop_words.utf8")
{
    std::ifstream ifs("/home/zhang/SearchEngine/corpus/stopwords/cn_stopwords.txt");
    string word;
    while (ifs >> word)
    {
        m_stopWords.insert(word);
    }
}


void PageProcessor::process(const std::string &dir)
{
    extract_documents(dir);
    deduplicate_documents();
    build_pages_and_offsets("../data/webpages.dat", "../data/weboffset.dat");
    build_inverted_index("../data/invertindex.dat");
}

// æå–æ–‡æ¡£
void PageProcessor::extract_documents(const std::string &dir)
{
    // è·å–ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶è·¯å¾„
    auto files = DirectoryScanner::scan(dir);
    int id = 0;

    for (auto &file : files)
    {
        XMLDocument doc;
        if (doc.LoadFile(file.c_str()) != XML_SUCCESS)
        {
            std::cerr << "Error: cannot load xml file " << file << std::endl;
            continue;
        }

        XMLElement *root = doc.RootElement();
        if (!root)
            continue;

        // å…ˆæ‰¾ channel
        XMLElement *channel = root->FirstChildElement("channel");
        XMLElement *item = nullptr;
        if (channel)
        {
            item = channel->FirstChildElement("item");
        }
        else
        {
            item = root->FirstChildElement("item"); // æœ‰äº›è¯­æ–™ç›´æ¥åœ¨ root ä¸‹
        }

        while (item)
        {
            Document d;
            d.id = id++;

            XMLElement *title = item->FirstChildElement("title");
            XMLElement *link = item->FirstChildElement("link");

            if (title && title->GetText())
                d.title = title->GetText();
            if (link && link->GetText())
                d.link = link->GetText();

            // å¦‚æœitemä¸­æœ‰content
            XMLElement *cont = item->FirstChildElement("content");
            if (cont && cont->GetText())
            {
                d.content = cont->GetText();
            }
            else
            {
                XMLElement *desc = item->FirstChildElement("description");
                if (desc && desc->GetText())
                {
                    d.content = desc->GetText();
                }
            }

            // 4. åªæœ‰å½“ content éç©ºæ—¶ï¼Œæ‰åŠ å…¥ m_documents
            if (!d.content.empty())
            {
                m_documents.push_back(std::move(d));
            }

            item = item->NextSiblingElement("item");
        }
    }
}

// è®¡ç®—æ±‰æ˜è·ç¦»
/* static int hammingDistance(uint64_t hashValue, uint64_t hash)
{
    int xOR = hashValue ^ hash;
    int distance = 0;
    while (xOR)
    {
        distance += (xOR & 1);
        xOR >>= 1;
    }
    return distance;
} */

// é«˜æ•ˆæ±‰æ˜è·ç¦»
static inline int hammingDistance(uint64_t hashValue, uint64_t hash)
{
    return __builtin_popcountll(hashValue ^ hash); // ç¡¬ä»¶æŒ‡ä»¤
}

// æ–‡æ¡£å»é‡
void PageProcessor::deduplicate_documents()
{
    vector<Document> uniqueDocs;
    set<uint64_t> check_hash;

    for (auto &doc : m_documents)
    {
        uint64_t hashValue = 0;
        // ç›´æ¥ç”¨ make ç”Ÿæˆ simhash
        if (!m_hasher.make(doc.content, 200, hashValue))
        {
            std::cerr << "Simhash make() failed for doc: " << doc.id << std::endl;
            continue;
        }

        bool duplicate = false;
        for (auto &hash : check_hash)
        {
            // XOR: æ‰¾å‡ºä¸åŒä½
            int dist = hammingDistance(hashValue, hash); // æ±‰æ˜è·ç¦»
            if (dist <= 3)                               // é˜ˆå€¼: â‰¤3 è¡¨ç¤ºç›¸ä¼¼
            {
                duplicate = true;
                break;
            }
        }

        if (!duplicate)
        {
            check_hash.insert(hashValue); // simhash è®°å½•åˆ°é›†åˆï¼Œæ–¹ä¾¿åç»­æŸ¥é‡
            uniqueDocs.push_back(doc);
        }
    }

    m_documents.swap(uniqueDocs); // æ›¿æ¢æ‰åŸæ¥çš„æ‰€æœ‰æ–‡æ¡£
}

// ç”Ÿæˆç½‘é¡µåº“å’Œåç§»åº“
void PageProcessor::build_pages_and_offsets(const string &pagesFile, const string &offsetsFile)
{
    ofstream ofsPages(pagesFile);
    ofstream ofsOffsets(offsetsFile);

    int offset = 0;
    for (auto &doc : m_documents)
    {
        ostringstream oss;
        oss << "<doc>\n"
            << "  <id>" << doc.id << "</id>\n"
            << "  <link>" << doc.link << "</link>\n"
            << "  <title>" << doc.title << "</title>\n"
            << "  <content>" << doc.content << "</content>\n"
            << "</doc>\n";

        string page = oss.str();
        ofsPages << page;

        ofsOffsets << doc.id << " " << offset << " " << page.size() << "\n";
        offset += page.size();
    }
}

// å»ºç«‹å€’æ’ç´¢å¼•
void PageProcessor::build_inverted_index(const std::string &indexFile)
{
    // è®¡ç®— TF-IDF
    unordered_map<string, int> df;                             // åŒ…å«è¯¥å…³é”®å­—çš„æ–‡æ¡£ä¸ªæ•°
    vector<unordered_map<string, int>> tf(m_documents.size()); // å…³é”®å­—åœ¨æ–‡æ¡£ä¸­å‡ºç°çš„æ¬¡æ•°

    for (size_t i = 0; i < m_documents.size(); ++i)
    {
        vector<string> words;                                 // å­˜åˆ†è¯ç»“æœ
        m_tokenizer.Cut(m_documents[i].content, words, true); // HMMæ··åˆæ¨¡å¼

        for (auto &word : words)
        {
            if (m_stopWords.count(word))
                continue;
            ++tf[i][word]; // ç¬¬iç¯‡æ–‡ç« ä¸­wordå‡ºç°çš„æ¬¡æ•°
        }
        for (auto &kv : tf[i]) // åœ¨åŒä¸€ç¯‡æ–‡æ¡£é‡Œå¤šæ¬¡å‡ºç°ä¹Ÿåªç®—ä¸€æ¬¡ DF
            ++df[kv.first];
    }

    size_t N = m_documents.size();
    for (size_t i = 0; i < N; ++i)
    {
        for (auto &[w, freq] : tf[i])
        {
            double idf = log((double)N / (df[w] + 1));
            double weight = freq * idf;
            m_invertedIndex[w][m_documents[i].id] = weight;
        }
    }

    ofstream ofs(indexFile);
    for (auto &[word, postings] : m_invertedIndex)
    {
        ofs << word << " ";
        for (auto &[docId, weight] : postings)
        {
            ofs << docId << " " << weight << " ";
        }
        ofs << "\n";
    }
}
===== PageProcessor.hpp =====
#pragma once
#include <string>
#include <vector>
#include <set>
#include "cppjieba/Jieba.hpp"
#include "simhash/Simhasher.hpp"

class PageProcessor
{
public:
    PageProcessor();
    void process(const std::string& dir);

private:
    void extract_documents(const std::string& dir);
    void deduplicate_documents();
    void build_pages_and_offsets(const std::string& pages, const std::string& offsets);
    void build_inverted_index(const std::string& filename);
private:
    struct Document 
    {
        int id;
        std::string link;
        std::string title;
        std::string content;
    };

private:
    cppjieba::Jieba m_tokenizer;
    simhash::Simhasher m_hasher;
    std::set<std::string> m_stopWords;    // ä½¿ç”¨set, è€Œévector, æ˜¯ä¸ºäº†æ–¹ä¾¿æŸ¥æ‰¾
    std::vector<Document> m_documents;    
    std::map<std::string, std::map<int, double>> m_invertedIndex;
};

===== ProtocolParser.cpp =====
#include "ProtocolParser.hpp"
#include <iostream>
#include <cstring>
using namespace std;

// ProtocolParser.cpp
bool ProtocolParser::Parse(const std::string &raw, Message &msg)
{
    if (raw.size() < 2 * sizeof(int))
    {
        return false; // tag + length
    }

    const char *p = raw.data();
    int tag = 0, length = 0;

    // ç”¨ memcpy é¿å…æœªå¯¹é½çš„é—®é¢˜
    std::memcpy(&tag, p, sizeof(int));
    p += sizeof(tag);// 
    std::memcpy(&length, p, sizeof(int));
    p += sizeof(length);

    if (length < 0)
        return false;
    if (raw.size() < 2 * sizeof(int) + length)
    {
        return false; // åŒ…ä½“ä¸å®Œæ•´
    }

    msg.tag = tag;
    msg.length = length;
    msg.value.assign(p, length);
    return true; // âœ… åˆ«å¿˜äº†
}

std::string ProtocolParser::serialize(const Message &msg)
{
    string raw;
    raw.reserve(msg.length + 2 * sizeof(int)); // é¢„ç•™ç©ºé—´

    // æ¶ˆæ¯å†™å…¥å†…å­˜
    raw.append(reinterpret_cast<const char *>(&msg.tag), sizeof(int));
    raw.append(reinterpret_cast<const char *>(&msg.length), sizeof(int));
    raw.append(msg.value);

    return raw;
}===== ProtocolParser.hpp =====
#pragma once
#include <iostream>

struct Message
{
    int tag;
    int length;
    std::string value;
};

class ProtocolParser
{
public:
    ProtocolParser() {}
    ~ProtocolParser() {}

    // ä»å­—èŠ‚æµè§£æä¸º Message
    static bool Parse(const std::string &raw,Message &msg);
    // å°†Messageåºåˆ—åŒ–ä¸ºå­—èŠ‚æµ
    static std::string serialize(const Message &msg);
};
===== RedisClient.hpp =====
#pragma once
#include <sw/redis++/redis++.h>
#include <memory>
#include <string>
#include <hiredis/hiredis.h>
#include <string>
using std::string;
using namespace sw::redis;
using std::make_unique;
using std::unique_ptr;

class RedisClient
{
public:
    RedisClient(const string &uri = "tcp://127.0.0.1:6379")
    {
        _redis = make_unique<sw::redis::Redis>(uri);
    }

    // æŸ¥è¯¢ key å¯¹åº”çš„å€¼
    bool get(const string &key, string &value)
    {
        auto val = _redis->get(key);
        if (val)
        {
            value = *val;
            return true;
        }
        return false;
    }

    void set(const string &key, const string &value, int ttl = 3600)
    {
        _redis->set(key, value);
        _redis->expire(key, ttl); // è¿‡æœŸæ—¶é—´
    }

private:
    unique_ptr<sw::redis::Redis> _redis;
};
===== SearchEngineServer.cpp =====
#include "SearchEngineServer.hpp"
#include "Logger.hpp"
#include "ProtocolParser.hpp"
#include "CacheManage.hpp"
#include <functional>
#include <iostream>
using namespace std;

// å…¨å±€é™æ€ç¼“å­˜ç®¡ç†å™¨ï¼ˆå®¹é‡1000ï¼Œå¯é…ç½®åŒ–ï¼‰
static CacheManage cache(100, "tcp://127.0.0.1:6379");


SearchEngineServer::SearchEngineServer(const std::string &ip, int port)
    : _tcpserver(ip, port), _threadpool(4, 10) {}

void SearchEngineServer::start()
{
    _threadpool.start();
    // æ³¨å†Œä¸‰ä¸ªå›è°ƒå‡½æ•°
    _tcpserver.setAllCallback(
        std::bind(&SearchEngineServer::onConnection, this, std::placeholders::_1),
        std::bind(&SearchEngineServer::onMessage, this, std::placeholders::_1),
        std::bind(&SearchEngineServer::onClose, this, std::placeholders::_1));

    LOG_INFO("SearchEngineServer start ...");
    _tcpserver.start();
}

void SearchEngineServer::stop()
{
    _threadpool.stop();
    _tcpserver.stop();
    LOG_INFO("SearchEngineServer stop ...");
}

void SearchEngineServer::onConnection(const TcpConnectionPtr &conn)
{
    string msg = conn->toString() + " has connected.";
    LOG_INFO(msg.c_str());
}

// ä»»åŠ¡åˆ°è¾¾ï¼Œè®©çº¿ç¨‹æ± æ¥æ‰§è¡Œä»»åŠ¡
void SearchEngineServer::onMessage(const TcpConnectionPtr &conn)
{
    string msg = conn->receive(); // å·²ç»æ˜¯å®Œæ•´åŒ…
    if (!msg.empty())
    {
        LOG_INFO(("received msg size=" + to_string(msg.size())).c_str());
        _threadpool.addTask(std::bind(&SearchEngineServer::doTaskThread, this, conn, msg));
    }
    else
    {
        LOG_INFO("peer closed connection");
    }
}

void SearchEngineServer::onClose(const TcpConnectionPtr &conn)
{
    string msg = conn->toString() + " has closed.";
    LOG_INFO(msg.c_str());
}

void SearchEngineServer::doTaskThread(const TcpConnectionPtr &conn, std::string &msg)
{
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨ ProtocolParser è§£åŒ…
     Message message;
    if (!ProtocolParser::Parse(msg, message))
    {
        LOG_WARN("Protocol parse error");
        conn->sendInLoop("{\"error\":\"Parse error\"}\n");
        return;
    }

    // æ‹¼æ¥ç¼“å­˜ key: "tag:value"
    string cacheKey = std::to_string(message.tag) + ":" + message.value;
    string result = cache.get(cacheKey);

    conn->sendInLoop(result + "\n");
    LOG_INFO("Query result sent to client");
}
===== SearchEngineServer.hpp =====
#pragma once
#include "TcpServer.hpp"
#include "ThreadPool.hpp"
class SearchEngineServer
{
public:
    SearchEngineServer(const std::string &ip,int port);
    ~SearchEngineServer() = default;
    void start();
    void stop();
    void onConnection(const TcpConnectionPtr &cb_conn);
    void onMessage(const TcpConnectionPtr &cb_mess);
    void onClose(const TcpConnectionPtr &cb_close);
    void doTaskThread(const TcpConnectionPtr &, std::string &msg);

private:
    TcpServer _tcpserver;
    ThreadPool _threadpool;
};

===== Socket.cpp =====
/**
 * Project 66th
 */

#include "Socket.hpp"

/**
 * Socket implementation
 */

Socket::Socket()
{
    _fd = socket(AF_INET,SOCK_STREAM,0);
    if(_fd < 0){
        perror("socket");
        return;
    }
}

/**
 * @param fd
 */
Socket::Socket(int fd)
{
    _fd = fd;
}

Socket::~Socket()
{
}

/**
 * @return int
 */
int Socket::getFd()
{
    return _fd;
}===== Socket.hpp =====
/**
 * Project 66th
 */

#pragma once
#include <sys/types.h> 
#include <sys/socket.h>
#include <iostream>

class Socket
{
public:
    Socket();

    /**
     * @param fd
     */
    explicit Socket(int fd);

    ~Socket();

    int getFd();

private:
    int _fd;
};
===== SocketIO.cpp =====
/**
 * Project 66th
 */

#include "SocketIO.hpp"

/**
 * SocketIO implementation
 */

/**
 * @param fd
 */
SocketIO::SocketIO(int fd) : _fd(fd)
{
}

SocketIO::~SocketIO()
{
}

/**
 * @param buf
 * @param len
 * @return int
 */
int SocketIO::readn(char *buf, int len)
{
    int left = len;
    char *pstr = buf;
    while (left > 0)
    {
        int nread = ::recv(_fd, pstr, left, 0);
        if (nread < 0)
        {
            if (errno == EINTR)
                continue;      // è¢«ä¿¡å·æ‰“æ–­é‡è¯•
            return len - left; // å‡ºé”™è¿”å›å·²è¯»å­—èŠ‚æ•°
        }
        else if (nread == 0)
        {
            return len - left; // å¯¹ç«¯å…³é—­
        }
        else
        {
            left -= nread;
            pstr += nread;
        }
    }
    return len;
}

/**
 * @param buf
 * @param len
 * @return int
 */
int SocketIO::readLine(char *buf, int len)
{
    int total = 0, ret = 0;
    int left = len - 1; // é¢„ç•™1å­—èŠ‚æ”¾å­—ç¬¦ä¸²ç»“å°¾'\0'
    char *pstr = buf;

    while (left > 0)
    {
        int ret = recv(_fd, pstr, left, MSG_PEEK);
        if (ret == 0)
        {
            break; // å¯¹ç«¯å…³é—­
        }
        else if (ret == -1 && errno == EINTR)
        {
            continue; // å‘ç”Ÿä¸­æ–­
        }
        else // peekåˆ°æ•°æ®ï¼ŒæŸ¥æ‰¾æœ‰æ— '\n'
        {
            int idx = 0;
            for (; idx < ret; ++idx)
            {
                if (pstr[idx] == '\n')
                { // æ‰¾åˆ°äº†å°±æ¶ˆè´¹æ‰socketç¼“å†²åŒº
                    int size = idx + 1;
                    if (readn(pstr, size) != size)
                        return -1;
                    pstr += size;
                    total += size;
                    *pstr = '\0';
                    return total;
                }
            }
            // æ²¡æœ‰æ‰¾åˆ°\n,æŠŠpeekåˆ°çš„å…¨éƒ¨è¯»å‡ºæ¥
            if (readn(pstr, ret) != ret)
                return -1;
            pstr += ret;
            left -= ret;
            total += ret;
        }
    }
    *pstr = '\0';
    return total;
}

/**
 * @param buf
 * @param len
 * @return int
 */
int SocketIO::writen(char *buf, int len)
{
    int left = len;
    char *pstr = buf;
    while (left > 0)
    {
        int nwrite = write(_fd, pstr, left);
        if (nwrite == 0)
        {
            break; // å¯¹ç«¯å…³é—­
        }
        else if (nwrite == -1 && errno == EINTR)
        {
            continue; // å‘ç”Ÿä¸­æ–­
        }
        else
        {
            left -= nwrite;
            pstr += nwrite;
        }
    }
    return len;
}===== SocketIO.hpp =====
/**
 * Project 66th
 */

#pragma once
#include <string>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
using std::string;
class SocketIO
{
public:
    /**
     * @param fd
     */
    explicit SocketIO(int fd);

    ~SocketIO();

    /**
     * @param buf
     * @param len
     */
    int readn(char *buf, int len);

    /**
     * @param buf
     * @param len
     */
    int readLine(char *buf, int len);

    /**
     * @param buf
     * @param len
     */
    int writen(char *buf, int len);

private:
    int _fd;
};
===== TaskQueue.cpp =====
/**
 * Project 66th
 */


#include "TaskQueue.hpp"

/**
 * TaskQueue implementation
 */


/**
 * @param capa
 */
TaskQueue::TaskQueue(size_t capa) 
    : m_capacity(capa)
{}

TaskQueue::~TaskQueue() 
{}

/**
 * @param value
 * @return void
 */
//ç”Ÿäº§è€…çº¿ç¨‹ä¼šè°ƒç”¨pushå‡½æ•°
void TaskQueue::push(ElemType && value) {
    //1.å…ˆä¸Šé”
    unique_lock<mutex> ul(m_mtx);

    //2.åˆ¤æ»¡
    /* if(full()) */
    while(full())//é˜²æ­¢è™šå‡å”¤é†’
    {
        //å¦‚æœTaskQueueæ˜¯æ»¡çš„ï¼Œå°±åº”è¯¥è®©
        //ç”Ÿäº§è€…åœ¨æ¡ä»¶å˜é‡ä¸Šç­‰å¾…
        m_notFull.wait(ul);
        //åº•å±‚åŸç†æ˜¯ï¼šè®©ç”Ÿäº§è€…çº¿ç¨‹é˜»å¡ï¼Œ
        //ä¼šå…ˆé‡Šæ”¾é”ï¼Œç­‰åˆ°è¢«å”¤é†’æ—¶å†é‡æ–°æŒæœ‰é”
    }

    //å¦‚æœTaskQueueä¸æ˜¯æ»¡çš„ï¼Œ
    //ç”Ÿäº§è€…çº¿ç¨‹å°±å¯ä»¥å°†ç”Ÿäº§çš„æ•°æ®åŠ å…¥TaskQueue
    m_que.push(std::move(value));

    //å”¤é†’æ¶ˆè´¹è€…ï¼Œå¯ä»¥å¼€å§‹æ¶ˆè´¹ä»“åº“ä¸­çš„æ•°æ®
    m_notEmpty.notify_one();

    //3.è§£é”ï¼ˆè‡ªåŠ¨è¿›è¡Œï¼‰
}

/**
 * @return int
 */
//æ¶ˆè´¹è€…çº¿ç¨‹ä¼šè°ƒç”¨popå‡½æ•°
ElemType TaskQueue::pop() {
    unique_lock<mutex> ul(m_mtx);

    //å› ä¸ºæ­¤å¤„ä»…ä»…ä»¥ä»»åŠ¡é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºä½œä¸ºåˆ¤æ–­æ¡ä»¶
    //æ‰€ä»¥æœ€åçº¿ç¨‹æ± é€€å‡ºæ—¶å”¤é†’äº†å­çº¿ç¨‹
    //åˆä¼šé©¬ä¸Šé™·å…¥é˜»å¡
    //
    //ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œä¸”çº¿ç¨‹æ± ä¸é€€å‡ºï¼Œé‚£ä¹ˆåº”è¯¥é˜»å¡å­çº¿ç¨‹
    //ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œä¸”çº¿ç¨‹æ± é€€å‡ºï¼Œé‚£ä¹ˆä¸åº”è¯¥é˜»å¡å­çº¿ç¨‹
    while(empty() && m_flag)
    {
        m_notEmpty.wait(ul);
    }

    //m_flagä¸ºtrueæ„å‘³ç€çº¿ç¨‹æ± ä¸é€€å‡º
    //èƒ½å¤Ÿé€šè¿‡å‰é¢çš„å¾ªç¯å®Œå…¨æ˜¯å› ä¸ºempty()çš„ç»“æœä¸ºfalse
    //ä»£è¡¨ç€ä»»åŠ¡é˜Ÿåˆ—ä¸­æœ‰ä»»åŠ¡
    //æ‰èƒ½è¿›è¡Œå–ä»»åŠ¡
    if(m_flag)
    {
        ElemType temp = m_que.front();
        m_que.pop();

        //å”¤é†’ç”Ÿäº§è€…
        m_notFull.notify_one();

        return temp;
    }
    else
    {
        return nullptr;
    }
}

/**
 * @return bool
 */
bool TaskQueue::full() {
    return m_que.size() == m_capacity;
}

/**
 * @return bool
 */
bool TaskQueue::empty() {
    return m_que.size() == 0;
}

void TaskQueue::wakeup()
{
    m_flag = false;
    m_notEmpty.notify_all();
}
===== TaskQueue.hpp =====
/**
 * Project 66th
 */


#pragma once

#include <iostream>
#include <functional>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
using std::cout;
using std::endl;
using std::queue;
using std::thread;
using std::mutex;
using std::unique_lock;
using std::lock_guard;
using std::condition_variable;
using std::function;
using std::bind;

extern mutex coutMtx;

using ElemType = function<void()>;

class TaskQueue {
public: 

    /**
     * @param capa
     */
    TaskQueue(size_t capa);

    ~TaskQueue();

    /**
     * @param value
     */
    //å¾€TaskQueueä¸­æ·»åŠ æ•°æ®ï¼ˆä»»åŠ¡ï¼‰
    void push(ElemType && value);

    //ä»TaskQueueä¸­è·å–æ•°æ®ï¼ˆä»»åŠ¡ï¼‰
    ElemType pop();

    //åˆ¤æ»¡å’Œåˆ¤ç©ºï¼Œå¯¹åº”çš„çŠ¶æ€ä¸‹
    //åº”è¯¥è®©ï¼ˆç”Ÿäº§è€…æˆ–æ¶ˆè´¹è€…ï¼‰çº¿ç¨‹ç­‰å¾…
    bool full();    
    bool empty();
    
    //çº¿ç¨‹æ± é€€å‡ºæ—¶å”¤é†’æ‰€æœ‰é˜»å¡åœ¨m_notEmptyä¸Šçš„å­çº¿ç¨‹
    void wakeup();


private: 
    size_t m_capacity;//å®¹é‡
    queue<ElemType> m_que;//å­˜æ”¾æ•°æ®çš„æ•°æ®ç»“æ„
    mutex m_mtx;//TaskQueueä¸­çš„æ•°æ®æ˜¯å…±äº«èµ„æºï¼Œéœ€è¦é”ç®¡ç†
    condition_variable m_notEmpty;//éç©ºæ¡ä»¶å˜é‡
    condition_variable m_notFull;//éæ»¡æ¡ä»¶å˜é‡
    
    //æ·»åŠ ä¸€ä¸ªæ ‡å¿—ä½ï¼Œå‚ä¸åˆ°popçš„åˆ¤æ–­ä¸­
    //ä¸ºäº†è®©çº¿ç¨‹æ± é€€å‡ºæ—¶ï¼Œå­çº¿ç¨‹èƒ½å¤Ÿä¸å†é˜»å¡
    bool m_flag = true;                
};

===== TcpConnection.cpp =====
/**
 * Project 66th
 */

#include "TcpConnection.hpp"
#include "Logger.hpp"
#include <cstring>
#include <iostream>

/**
 * TcpConnection implementation
 */

/**
 * @param fd
 * @param loop
 */
TcpConnection::TcpConnection(int fd, EventLoop *loop)
    : _sock(fd), _sockIO(fd), _localAddr(getLocalAddr()), _peerAddr(getPeerAddr()), _loop(loop)
{
}

TcpConnection::~TcpConnection()
{
}

/**
 * @return bool
 */
// è¿›è¡Œä¸€æ¬¡å¤åˆ¶å¼çš„é¢„è¯»å–
// å¦‚æœè¯»åˆ°çš„å­—ç¬¦æ•°ä¸º0ï¼Œä»£è¡¨è¿æ¥å·²ç»æ–­å¼€äº†
bool TcpConnection::isClosed()
{
    char buf[5] = {0};
    int ret = ::recv(_sock.getFd(), buf, sizeof(buf), MSG_PEEK);
    if (ret < 0)
    {
        LOG_ERROR("recv(MSG_PEEK) failed");
    }
    return 0 == ret;
}

/**
 * @return string
 */
string TcpConnection::receive()
{
    // å…ˆè¯» 8 å­—èŠ‚å¤´
    int headSize = sizeof(int) * 2;
    char header[8] = {0};
    int n = _sockIO.readn(header, headSize);
    if (n == 0)
    {
        return ""; // å¯¹ç«¯å…³é—­
    }
    else if (n < headSize)
    {
        return ""; // ä¸å®Œæ•´
    }

    int tag = 0;
    int length = 0;
    memcpy(&tag, header, 4);
    memcpy(&length, header + 4, 4);

    if (length < 0 || length > 10 * 1024 * 1024)
    {
        LOG_ERROR(("Invalid packet length: " + std::to_string(length)).c_str());
        return "";
    }

    string value(length, '\0');
    n = _sockIO.readn(&value[0], length);
    if (n < length)
    {
        LOG_WARN("Incomplete packet received");
        return "";
    }

    // è¿”å›å®Œæ•´äºŒè¿›åˆ¶åŒ…ï¼ˆå¤´+ä½“ï¼‰
    string packet;
    packet.append(header, headSize);
    packet.append(value);
    LOG_DEBUG(("Received packet length=" + std::to_string(length)).c_str());
    return packet;
}

/**
 * @param msg
 * @return void
 */
void TcpConnection::send(const string &msg)
{
    int n = _sockIO.writen(const_cast<char *>(msg.c_str()), msg.size());
    if (n < (int)msg.size())
    {
        LOG_ERROR("send failed or partial write");
    }
    else
    {
        LOG_DEBUG(("send success size=" + std::to_string(msg.size())).c_str());
    }
}
/**
 * @param msg
 * @return void
 */
void TcpConnection::sendInLoop(const string &msg)
{
    auto con = shared_from_this();
    _loop->runInLoop([con, msg]
                     { con->send(msg); });
}

/**
 * @return string
 */
string TcpConnection::toString()
{
    ostringstream oss;
    oss << _localAddr.getIp() << ":" << _localAddr.getPort() << "->" << _peerAddr.getIp() << ":" << _peerAddr.getPort();
    return oss.str();
}

/**
 * @param cb
 */
void TcpConnection::setNewConnectionCallback(const TcpConnectionCallBack &cb)
{
    _onNewConnection = cb;
}

/**
 * @param cb
 */
void TcpConnection::setMessageCallback(const TcpConnectionCallBack &cb)
{
    _onMessage = cb;
}

/**
 * @param cb
 */
void TcpConnection::setCloseCallback(const TcpConnectionCallBack &cb)
{
    _onClose = cb;
}

/**
 * @return void
 */
void TcpConnection::handleNewConnectionCallback()
{
    if (_onNewConnection)
        _onNewConnection(shared_from_this());
}

/**
 * @return void
 */
void TcpConnection::handleMessageCallback()
{
    if (_onMessage)
        _onMessage(shared_from_this());
}

/**
 * @return void
 */
void TcpConnection::handleCloseCallback()
{
    if (_onClose)
        _onClose(shared_from_this());
}

/**
 * @return InetAddress
 */
InetAddress TcpConnection::getLocalAddr()
{
    struct sockaddr_in localaddr;
    socklen_t addr_len = sizeof(localaddr);
    int ret = getsockname(_sock.getFd(), (struct sockaddr *)&localaddr, &addr_len);
    if (ret < 0)
    {
        perror("getsockname");
    }
    return InetAddress(localaddr);
}

/**
 * @return InetAddress
 */
InetAddress TcpConnection::getPeerAddr()
{
    struct sockaddr_in peeraddr;
    socklen_t addr_len = sizeof(peeraddr);
    int ret = getpeername(_sock.getFd(), (struct sockaddr *)&peeraddr, &addr_len);
    if (ret < 0)
    {
        perror("getpeername");
    }
    return InetAddress(peeraddr);
}===== TcpConnection.hpp =====
/**
 * Project 66th
 */

#pragma once
#include "SocketIO.hpp"
#include "Socket.hpp"
#include "InetAddress.hpp"
#include "EventLoop.hpp"
#include <string>
#include <sstream>
#include <memory>
#include <functional>
using std::function;
using std::ostringstream;
using std::shared_ptr;
using std::string;
class TcpConnection;
class EventLoop;
using TcpConnectionPtr = shared_ptr<TcpConnection>;
using TcpConnectionCallBack = function<void(const TcpConnectionPtr &)>;
class TcpConnection : public std::enable_shared_from_this<TcpConnection>
{
public:
    /**
     * @param fd
     * @param loop
     */
    TcpConnection(int fd, EventLoop *loop);

    ~TcpConnection();

    bool isClosed();

    string receive();

    /**
     * @param msg
     */
    void send(const string &msg);

    /**
     * @param msg
     */
    void sendInLoop(const string &msg);

    string toString();

    /**
     * @param cb
     */
    void setNewConnectionCallback(const TcpConnectionCallBack &cb);

    /**
     * @param cb
     */
    void setMessageCallback(const TcpConnectionCallBack &cb);

    /**
     * @param cb
     */
    void setCloseCallback(const TcpConnectionCallBack &cb);

    void handleNewConnectionCallback();

    void handleMessageCallback();

    void handleCloseCallback();

private:
    EventLoop *_loop;
    SocketIO _sockIO;
    Socket _sock;
    InetAddress _localAddr;
    InetAddress _peerAddr;
    TcpConnectionCallBack _onNewConnection;
    TcpConnectionCallBack _onMessage;
    TcpConnectionCallBack _onClose;

    InetAddress getLocalAddr();

    InetAddress getPeerAddr();
};

===== TcpServer.cpp =====
/**
 * Project 66th
 */

#include "TcpServer.hpp"
#include "EventLoop.hpp"

/**
 * TcpServer implementation
 */

/**
 * @param ip
 * @param port
 */
TcpServer::TcpServer(const string &ip, unsigned short port)
    : _acceptor(ip, port), _loop(_acceptor)
{
}

TcpServer::~TcpServer()
{
}

/**
 * @param cb1
 * @param cb2
 * @param cb3
 * @return void
 */
void TcpServer::setAllCallback(callback &&cb1, callback &&cb2, callback &&cb3)
{
    _loop.setNewConnectionCallBack(std::move(cb1));
    _loop.setMessageCallBack(std::move(cb2));
    _loop.setCloseCallBack(std::move(cb3));
}

/**
 * @return void
 */
void TcpServer::start()
{
    _acceptor.ready();
    _loop.loop();
}

/**
 * @return void
 */
void TcpServer::stop()
{
    _loop.unloop();
}
===== TcpServer.hpp =====
/**
 * Project 66th
 */


#pragma once

#include "Acceptor.hpp"
#include "EventLoop.hpp"


class TcpServer {
public: 
    using callback = function<void(const TcpConnectionPtr &)>;
    /**
     * @param ip
     * @param port
     */
    TcpServer(const string & ip, unsigned short port);

    ~TcpServer();

    void start();

    void stop();

    /**
     * @param cb1
     * @param cb2
     * @param cb3
     */
    void setAllCallback(callback && cb1, callback && cb2, callback &&cb3);
private: 
    Acceptor _acceptor;
    EventLoop _loop;
};


===== ThreadPool.cpp =====
/**
 * Project 66th
 */


#include "ThreadPool.hpp"
#include <unistd.h>

/**
 * ThreadPool implementation
 */


/**
 * @param threadNum
 * @param queSize
 */
ThreadPool::ThreadPool(size_t threadNum, size_t queSize) 
: m_threadNum(threadNum)
, m_threads()
, m_queSize(queSize)
, m_que(m_queSize)
, m_isExit(false)
{

}

ThreadPool::~ThreadPool() {

}

/**
 * @return void
 */
//çº¿ç¨‹æ± å¯åŠ¨
void ThreadPool::start() {
    for(size_t idx = 0; idx < m_threadNum; ++idx)
    {
        //çº¿ç¨‹æ± å¯åŠ¨åï¼Œéœ€è¦åˆ›å»ºm_threadNumä¸ªå­çº¿ç¨‹å¤‡ç”¨
        //ä½†æ˜¯å¾€vectorä¸­è¿›è¡Œpush_backæ—¶ä¸èƒ½ä¼ å·¦å€¼thread
        //å› ä¸ºè¿™æ ·ä¼šè§¦å‘threadçš„æ‹·è´æ„é€ ï¼Œ
        //è€Œthreadæ‹·è´æ„é€ è¢«åˆ é™¤
        //
        /* thread th(&ThreadPool::doTask,this); */
        /* m_threads.push_back(std::move(th)); */

        m_threads.push_back(thread(&ThreadPool::doTask,this));
    }
}

/**
 * @return void
*/
//å…³é—­çº¿ç¨‹æ± 
void ThreadPool::stop() {
    //ä¸»çº¿ç¨‹æ‰§è¡Œstopå‡½æ•°æ—¶ä¸åº”è¯¥è½»æ˜“åœ°æ”¹å˜æ ‡å¿—ä½
    //å¦‚æœå‘ç°ä»»åŠ¡é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œè¯´æ˜è¿˜æœ‰ä»»åŠ¡æ²¡æœ‰æ‰§è¡Œå®Œ
    while(!m_que.empty())
    {
        sleep(1);
    }

    //ä¿®æ”¹æ ‡å¿—ä½ï¼Œè¡¨ç¤ºçº¿ç¨‹æ± è¦é€€å‡º
    m_isExit = true;

    //éœ€è¦å°†threadPoolå£°æ˜ä¸ºTaskQueueçš„å‹å…ƒç±»
    /* m_que.m_notEmpty.notify_all(); */
    m_que.wakeup();
    
    //è®©ä¸»çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹é€€å‡º
    for(auto & th : m_threads)
    {
        th.join();
    }
}

/**
 * @param ptask
 * @return void
 */
void ThreadPool::addTask(ElemType && ptask) {
    //å› ä¸ºå¦‚æœå‡ºç°ç©ºæŒ‡é’ˆè°ƒç”¨è™šå‡½æ•°çš„æƒ…å†µ
    //ä¸€å®šä¼šå‘ç”Ÿæ®µé”™è¯¯ï¼Œæ‰€ä»¥åšä¸€ä¸ªæ£€æŸ¥
    if(ptask)
    {
        //ç”Ÿäº§è€…çº¿ç¨‹æŠŠä»»åŠ¡å¾€TaskQueueé‡Œé¢åŠ 
        //åŠ é”
        //åˆ¤æ»¡ï¼Œ
        //å¦‚æœæ»¡å°±é˜»å¡
        //å¦‚æœä¸æ»¡å°±pushï¼Œå¹¶ä¸”å”¤é†’é˜»å¡çš„æ¶ˆè´¹è€…çº¿ç¨‹ï¼ˆå­çº¿ç¨‹ï¼‰
        m_que.push(std::move(ptask)); //å·²ç»å®ç°è¿‡äº†ï¼ï¼ï¼
    }
}

/**
 * @return ElemType
 */
//ä»TaskQueueä¸­è·å–ä»»åŠ¡
ElemType ThreadPool::getTask() {
    return m_que.pop(); //å·²ç»å®ç°è¿‡äº†ï¼ï¼ï¼
}

/**
 * @return void
 */
//doTaskè¢«æ³¨å†Œä¸ºå·¥ä½œçº¿ç¨‹çš„å…¥å£å‡½æ•°
void ThreadPool::doTask() {
    //åªè¦çº¿ç¨‹æ± ä¸é€€å‡ºï¼Œå°±åº”è¯¥è®©å·¥ä½œçº¿ç¨‹ä¸€ç›´æ‰§è¡Œä»»åŠ¡
    while(!m_isExit){
        //å¦‚æœä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºï¼Œå°±è®©å·¥ä½œçº¿ç¨‹é˜»å¡
        ElemType ptask = getTask();
        
        if(ptask)
        {
            ptask();
            /* sleep(3); */
        }
        else
        {
            cout << "ptask == nullptr" << endl;
        }
    }
}
===== ThreadPool.hpp =====
/**
 * Project 66th
 */


#pragma once
#include "TaskQueue.hpp"
#include <vector>
using std::vector;


class ThreadPool {
public: 
    
/**
 * @param threadNum
 * @param queSize
 */

//æ„é€ å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°ä»£è¡¨å­çº¿ç¨‹çš„ä¸ªæ•°å’Œä»»åŠ¡é˜Ÿåˆ—çš„å®¹é‡
ThreadPool(size_t threadNum, size_t queSize);
~ThreadPool();
    
//æä¾›çº¿ç¨‹æ± å¯åŠ¨å’Œå…³é—­çš„å‡½æ•°
void start();
void stop();
    
/**
 * @param ptask
 */
//ç”Ÿäº§è€…çº¿ç¨‹å¯ä»¥å¾€çº¿ç¨‹æ± ä¸­æ·»åŠ ä»»åŠ¡
void addTask(ElemType && ptask);

private: 
    size_t m_threadNum;
    vector<thread> m_threads;
    size_t m_queSize;
    TaskQueue m_que;
    bool m_isExit;

//åœ¨doTaskä¸­è°ƒç”¨ï¼Œå°±æ˜¯ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–ä»»åŠ¡ä»¥ä¾¿åç»­æ‰§è¡Œ
ElemType getTask();

//æ³¨å†Œç»™å·¥ä½œçº¿ç¨‹ä½œä¸ºå…¥å£å‡½æ•°
void doTask();
};

===== WebPageSearcher.cpp =====
#include "WebPageSearcher.hpp"
#include <fstream>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <cctype>

// æ„é€ å‡½æ•°ï¼šåŠ è½½ç´¢å¼•ä¸åç§»è¡¨
WebPageSearcher::WebPageSearcher(const std::string &pagesFile, const std::string &offsetsFile, const std::string &indexFile)
    : _pagesFile(pagesFile)
{
    loadOffsets(offsetsFile);
    loadInvertIndex(indexFile);
}

// åŠ è½½åç§»åº“
void WebPageSearcher::loadOffsets(const std::string &offsetsFile)
{
    std::ifstream ifs(offsetsFile);
    if (!ifs.is_open())
    {
        std::cerr << "Error: cannot open offsets file " << offsetsFile << std::endl;
        return;
    }

    int id;
    size_t offset, len;
    while (ifs >> id >> offset >> len)
    {
        _offsetTable[id] = {id, offset, len};
    }
}

// åŠ è½½å€’æ’ç´¢å¼•åº“
void WebPageSearcher::loadInvertIndex(const std::string &indexFile)
{
    std::ifstream ifs(indexFile);
    if (!ifs.is_open())
    {
        std::cerr << "Error: cannot open invert index file " << indexFile << std::endl;
        return;
    }

    std::string line;
    while (std::getline(ifs, line))
    {
        std::istringstream iss(line);
        std::string word;
        iss >> word;
        int docId;
        double weight;
        while (iss >> docId >> weight)
        {
            _invertIdx[word][docId] = weight;
        }
    }
}

// ç®€å•åˆ†è¯ï¼ˆè‹±æ–‡æŒ‰ç©ºæ ¼ï¼Œä¸­æ–‡é€å­—ï¼‰
std::vector<std::string> WebPageSearcher::tokenize(const std::string &text)
{
    std::vector<std::string> res;
    bool isAscii = true;
    for (unsigned char c : text)
    {
        if (c & 0x80)
        {
            isAscii = false;
            break;
        }
    }

    if (isAscii)
    {
        std::istringstream iss(text);
        std::string token;
        while (iss >> token)
        {
            for (auto &ch : token)
                ch = std::tolower(ch);
            res.push_back(token);
        }
    }
    else
    {
        for (size_t i = 0; i < text.size();)
        {
            unsigned char c = text[i];
            int len = 1;
            if ((c & 0xF0) == 0xE0)
                len = 3; // ä¸­æ–‡å¸¸ç”¨
            else if ((c & 0xE0) == 0xC0)
                len = 2;
            else if ((c & 0xF8) == 0xF0)
                len = 4;
            if (i + len > text.size())
                break;
            res.push_back(text.substr(i, len));
            i += len;
        }
    }
    return res;
}

// UTF-8 å®‰å…¨æˆªæ–­ï¼ˆé¿å…æˆªåŠä¸ªæ±‰å­—ï¼‰
std::string WebPageSearcher::safeUtf8Substr(const std::string &str, size_t maxChars)
{
    std::string result;
    size_t i = 0, count = 0;
    while (i < str.size() && count < maxChars)
    {
        unsigned char c = str[i];
        size_t charLen = 1;
        if ((c & 0x80) == 0)
            charLen = 1;
        else if ((c & 0xE0) == 0xC0)
            charLen = 2;
        else if ((c & 0xF0) == 0xE0)
            charLen = 3;
        else if ((c & 0xF8) == 0xF0)
            charLen = 4;
        if (i + charLen > str.size())
            break; // é˜²æ­¢è¶Šç•Œ
        result.append(str.substr(i, charLen));
        i += charLen;
        count++;
    }
    return result;
}

// æ ¹æ® docId è·å–ç½‘é¡µç‰‡æ®µ
std::string WebPageSearcher::getDocSnippet(int docId)
{
    auto it = _offsetTable.find(docId);
    if (it == _offsetTable.end())
        return "";

    std::ifstream ifs(_pagesFile);
    if (!ifs.is_open())
        return "";

    ifs.seekg(it->second.offset);
    std::string buf(it->second.length, '\0');
    ifs.read(&buf[0], it->second.length);

    std::string title, content;
    size_t t1 = buf.find("<title>");
    size_t t2 = buf.find("</title>");
    if (t1 != std::string::npos && t2 != std::string::npos)
    {
        title = buf.substr(t1 + 7, t2 - (t1 + 7));
    }
    size_t c1 = buf.find("<content>");
    size_t c2 = buf.find("</content>");
    if (c1 != std::string::npos && c2 != std::string::npos)
    {
        std::string rawContent = buf.substr(c1 + 9, c2 - (c1 + 9));
        content = safeUtf8Substr(rawContent, 100); // æŒ‰å­—ç¬¦æˆªæ–­
    }
    return title + " : " + content;
}

// æ‰§è¡ŒæŸ¥è¯¢
std::string WebPageSearcher::doQuery(const std::string &query)
{
    auto words = tokenize(query);
    std::unordered_map<int, double> docScores;

    for (auto &w : words)
    {
        if (_invertIdx.count(w))
        {
            for (auto &[docId, weight] : _invertIdx[w])
            {
                docScores[docId] += weight;
            }
        }
    }

    std::vector<std::pair<int, double>> results(docScores.begin(), docScores.end());
    std::sort(results.begin(), results.end(),
              [](auto &a, auto &b)
              { return a.second > b.second; });

    nlohmann::json j;
    j["query"] = query;
    j["results"] = nlohmann::json::array();

    for (int i = 0; i < std::min(5, (int)results.size()); ++i)
    {
        int docId = results[i].first;
        j["results"].push_back({{"docId", docId},
                                {"score", results[i].second},
                                {"snippet", getDocSnippet(docId)}});
    }

    if (results.empty())
    {
        j["results"] = nlohmann::json::array();
        j["msg"] = "æœªæ‰¾åˆ°ç›¸å…³ç»“æœ";
    }
    return j.dump(4);
}
===== WebPageSearcher.hpp =====
#pragma once
#include <string>
#include <unordered_map>
#include <map>
#include <vector>
#include <nlohmann/json.hpp>

// ç½‘é¡µæœç´¢å™¨
class WebPageSearcher {
public:
    WebPageSearcher(const std::string& pagesFile,
                    const std::string& offsetsFile,
                    const std::string& indexFile);

    // æ‰§è¡ŒæŸ¥è¯¢ï¼Œè¿”å› JSON ç»“æœ
    std::string doQuery(const std::string& query);

private:
    struct Offset {
        int docId;
        size_t offset;
        size_t length;
    };

    // åŠ è½½æ•°æ®
    void loadOffsets(const std::string& offsetsFile);
    void loadInvertIndex(const std::string& indexFile);

    // å·¥å…·
    std::vector<std::string> tokenize(const std::string& text);
    std::string getDocSnippet(int docId);

    // å®‰å…¨ UTF-8 æˆªæ–­
    static std::string safeUtf8Substr(const std::string &str, size_t maxChars);

    // æ•°æ®ç»“æ„
    std::unordered_map<int, Offset> _offsetTable;                       // åç§»è¡¨
    std::unordered_map<std::string, std::map<int, double>> _invertIdx;  // å€’æ’ç´¢å¼•
    std::string _pagesFile;                                             // ç½‘é¡µåº“è·¯å¾„
};
